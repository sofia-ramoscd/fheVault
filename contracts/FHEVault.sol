// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, euint64, externalEuint64} from "@fhevm/solidity/lib/FHE.sol";
import {SepoliaConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title FHEVault
/// @notice Vault allowing users to stake ETH for encrypted fETH, lock balances, and redeem after expiry.
contract FHEVault is SepoliaConfig {
    struct LockPosition {
        euint64 encryptedAmount;
        uint256 plainAmount;
        uint64 unlockTime;
        bool active;
    }

    mapping(address => euint64) private encryptedBalances;
    mapping(address => uint256) private plainBalances;
    mapping(address => LockPosition) private locks;

    bool private reentrancyGuard;

    event Staked(address indexed user, uint256 amount);
    event Redeemed(address indexed user, uint256 amount);
    event Locked(address indexed user, uint256 amount, uint64 unlockTime);
    event LockReleased(address indexed user, uint256 amount);

    modifier nonReentrant() {
        require(!reentrancyGuard, "ReentrancyGuard: reentrant call");
        reentrancyGuard = true;
        _;
        reentrancyGuard = false;
    }

    receive() external payable {
        stake();
    }

    /// @notice Stake ETH to receive encrypted fETH points.
    function stake() public payable nonReentrant {
        uint256 amount = msg.value;
        require(amount > 0, "Amount must be greater than zero");
        require(amount <= type(uint64).max, "Amount too large");

        plainBalances[msg.sender] += amount;

        euint64 minted = FHE.asEuint64(uint64(amount));
        euint64 updatedBalance = FHE.add(encryptedBalances[msg.sender], minted);
        encryptedBalances[msg.sender] = updatedBalance;

        FHE.allowThis(updatedBalance);
        FHE.allow(updatedBalance, msg.sender);

        emit Staked(msg.sender, amount);
    }

    /// @notice Redeem available fETH back to ETH.
    /// @param amount Plain amount of ETH to withdraw measured in wei.
    function redeem(uint256 amount) external nonReentrant {
        require(amount > 0, "Amount must be greater than zero");
        require(amount <= type(uint64).max, "Amount too large");
        require(plainBalances[msg.sender] >= amount, "Insufficient balance");

        plainBalances[msg.sender] -= amount;

        euint64 reduction = FHE.asEuint64(uint64(amount));
        euint64 updatedBalance = FHE.sub(encryptedBalances[msg.sender], reduction);
        encryptedBalances[msg.sender] = updatedBalance;

        FHE.allowThis(updatedBalance);
        FHE.allow(updatedBalance, msg.sender);

        (bool success, ) = msg.sender.call{value: amount}("");
        require(success, "ETH transfer failed");

        emit Redeemed(msg.sender, amount);
    }

    /// @notice Lock encrypted fETH for a chosen duration.
    /// @param amount Plain amount used for accounting (wei)
    /// @param duration Lock duration in seconds
    /// @param encryptedAmount Encrypted representation of the amount
    /// @param inputProof Proof generated by the Zama SDK for the encrypted amount
    function lock(
        uint256 amount,
        uint64 duration,
        externalEuint64 encryptedAmount,
        bytes calldata inputProof
    ) external nonReentrant {
        require(amount > 0, "Amount must be greater than zero");
        require(amount <= type(uint64).max, "Amount too large");
        require(duration > 0, "Duration must be greater than zero");

        LockPosition storage position = locks[msg.sender];
        require(!position.active, "Lock already active");
        require(plainBalances[msg.sender] >= amount, "Insufficient balance");

        plainBalances[msg.sender] -= amount;

        euint64 reduction = FHE.asEuint64(uint64(amount));
        euint64 updatedBalance = FHE.sub(encryptedBalances[msg.sender], reduction);
        encryptedBalances[msg.sender] = updatedBalance;

        FHE.allowThis(updatedBalance);
        FHE.allow(updatedBalance, msg.sender);

        euint64 lockAmount = FHE.fromExternal(encryptedAmount, inputProof);
        uint64 unlockTime = uint64(block.timestamp + duration);

        position.encryptedAmount = lockAmount;
        position.plainAmount = amount;
        position.unlockTime = unlockTime;
        position.active = true;

        FHE.allowThis(lockAmount);
        FHE.allow(lockAmount, msg.sender);

        emit Locked(msg.sender, amount, unlockTime);
    }

    /// @notice Release a matured lock and recover encrypted balance.
    function releaseLock() external nonReentrant {
        LockPosition storage position = locks[msg.sender];
        require(position.active, "No active lock");
        require(block.timestamp >= position.unlockTime, "Lock not matured");

        uint256 amount = position.plainAmount;
        euint64 lockedAmount = position.encryptedAmount;

        plainBalances[msg.sender] += amount;

        euint64 updatedBalance = FHE.add(encryptedBalances[msg.sender], lockedAmount);
        encryptedBalances[msg.sender] = updatedBalance;

        FHE.allowThis(updatedBalance);
        FHE.allow(updatedBalance, msg.sender);

        position.active = false;
        position.unlockTime = 0;
        position.plainAmount = 0;
        position.encryptedAmount = FHE.asEuint64(0);

        FHE.allowThis(position.encryptedAmount);
        FHE.allow(position.encryptedAmount, msg.sender);

        emit LockReleased(msg.sender, amount);
    }

    /// @notice Get encrypted fETH balance for a user.
    function getEncryptedBalance(address user) external view returns (euint64) {
        return encryptedBalances[user];
    }

    /// @notice Get plain available balance (non-locked) for a user.
    function getAvailableBalance(address user) external view returns (uint256) {
        return plainBalances[user];
    }

    /// @notice Get lock information for a user.
    function getLockInfo(address user)
        external
        view
        returns (bool active, uint64 unlockTime, euint64 encryptedAmount, uint256 plainAmount)
    {
        LockPosition storage position = locks[user];
        if (!position.active) {
            return (false, 0, position.encryptedAmount, 0);
        }

        return (true, position.unlockTime, position.encryptedAmount, position.plainAmount);
    }

    /// @notice Check whether the user can release their lock.
    function canRelease(address user) external view returns (bool) {
        LockPosition storage position = locks[user];
        return position.active && block.timestamp >= position.unlockTime;
    }
}
